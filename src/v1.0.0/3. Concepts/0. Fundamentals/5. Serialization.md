# Fuel EIP712 Serialization Specification

This document describes the Fuel EIP712 specification, including `encodeTypes`, and `encodeDate` functions.
EIP712 improves usability of off-chain message signatures for use on-chain by specifying a standard for hashing and signing of typed (semi-)structured data (not just bytes).

The Fuel EIP712 specification contributes a scalability solution that has trust-minimized security with Ethereum and other EIP712 messages.
The Fuel EIP712 specification thus confers:

 * _minimum_ equivalence amongst _all_ Fuel EIP712-conforming implementations
 * _scalable_ composability with the set of _all_ EIP712 message specifications

## encodeTypes

### Address

`encodeData`:

* require `Output.owner.length > 0`
* require `Output.owner.length <= 20`
* `Output.owner =`
  * `if Output.owner.length == 20 then Output.owner`
  * `else Output.owner[:Output.owner.length]`

### Input

`Input(uint8 type,uint8 witnessReference)`

### InputDeposit

`InputDeposit(uint8 type,uint8 witnessReference,address owner)`

### InputHTLC

`InputHTLC(uint8 type,uint8 witnessReference,bytes32 preImage)`

#### Metadata

`Metadata(uint32 blockHeight,uint8 rootIndex,uint16 transactionIndex,uint8 outputIndex)`

### MetadataDeposit

`MetadataDeposit(uint32 token,uint32 blockNumber)`

### Output

`Output(uint8 type,uint8 tokenLength,bytes1[] token,uint8 amountShift,uint8 amountLength,uint8[] amount,uint8 ownerLength,bytes1[] owner)`

encodeData for `Output`:

* require `amountLength <= 32`
* require `amountShift <= 256`
* require `((amountLength * 8) + amountShift) <= 256`
* `Output.amount = Output.amount.data[:Output.amountLength] << Output.amountShift`

### OutputHTLC

`OutputHTLC(uint8 type,uint8 tokenLength,bytes1[] token,uint8 amountShift,uint8 amountLength,uint8[] amount,uint8 ownerLength,bytes1[] owner,bytes32 digest,uint32 expiry,uint8 returnOwnerLength,bytes1[] returnOwner)`

### OutputReturn

`OutputReturn(uint8 type,uint16 dataLength,bytes1[] data)`

### Storage

Base type for stored types. Computes index into storage of 1-, 2-, or 3-element items:

* mapping key for 1-element item is: `keccak256(0, 64)`
* mapping key for 2-element item is: `keccak256(0, 96)`
* mapping key for 3-element item is: `keccak256(0, 128)`

### TransactionProof

`TransactionProof(address blockProducer,bytes32 previousBlockHash,uint256 blockHeight,uint256 blockNumber,uint256 numTokens,uint256 numAddresses,uint16 rootsLength,bytes32[] roots,address rootProducer,bytes32 merkleTreeRoot,bytes32 commitmentHash,uint256 rootLength,uint256 feeToken,uint256 fee,uint16 rootIndex,uint16 merkleProofLength,bytes32[] merkleProof,uint8 inputOutputIndex,uint16 transactionIndex,uint16 transactionLength,bytes1[] transaction,uint8 dataLength,bytes32[] data,uint256 signatureFeeToken,uint256 signatureFee,address tokenAddress,address selector)`

### TransactionLeaf

`TransactionLeaf(uint16 length,uint8 metadataLength,bytes8[] metadata,uint16 witnessesLength,bytes1[] witnesses,uint16 inputsLength,bytes1[] inputs,uint16 outputsLength,bytes1[] outputs)`

### UTXO

`UTXO(bytes32 transactionId,uint256 outputIndex,uint256 outputType,bytes32 owner,uint256 amount,uint256 token,bytes32 digest,uint256 expiry,bytes32 returnOwner)`

### Witness

There is no explicit `Witness` type, only its sub-types of Signature, Caller, and  Producer.

`Signature(uint8 type,bytes32 r,bytes32 s,uint8 v)`

`Caller(uint8 type,address owner,uint32 blockNumber)`

`Producer(uint8 type,bytes32 hash)`
